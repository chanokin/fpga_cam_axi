
#include "helloworld.h"



XIicPs I2C_dev;
XIicPs_Config *I2C_config;
u8 SendBuffer[IIC_BUFFER_SIZE];    /**< Buffer for Transmitting Data */
XGpio Power_Clock_GPIO;

volatile static int Done = 0;	/* Dma transfer is done */
volatile static int Error = 0;	/* Dma Bus Error occurs */

XScuGic Gic;			/* PS GIC -- interrupt*/

static void dma_CallBack(void *CallBackRef, u32 IrqMask, int *IgnorePtr)
{

	if (IrqMask & XAXICDMA_XR_IRQ_ERROR_MASK) {
		Error = 1;
	}

	if (IrqMask & XAXICDMA_XR_IRQ_IOC_MASK) {
		Done = 1;
	}

}

int setup_cdma_interrupts(XScuGic *GicPtr, XAxiCdma  *DmaPtr){
	int Status;

	Xil_ExceptionInit();

	// Connect the interrupt controller interrupt handler to the hardware
	// interrupt handling logic in the processor.
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT,
			     (Xil_ExceptionHandler)XScuGic_InterruptHandler,
			     GicPtr);

	// Connect a device driver handler that will be called when an interrupt
	// for the device occurs, the device driver handler performs the specific
	// interrupt processing for the device

	Status = XScuGic_Connect(GicPtr,
			XPAR_FABRIC_AXI_CDMA_0_CDMA_INTROUT_INTR,
				 (Xil_InterruptHandler)XAxiCdma_IntrHandler,
				 (void *)DmaPtr);
	if (Status != XST_SUCCESS)
		return XST_FAILURE;

	// Enable the interrupt for the device
	XScuGic_Enable(GicPtr, XPAR_FABRIC_AXI_CDMA_0_CDMA_INTROUT_INTR);

	return XST_SUCCESS;
}

int setup_cam_GPIO(XGpio *gpio, u16 dev, unsigned pwr_chn, u32 pwr_dir, unsigned clk_chn, u32 clk_dir){
	int Status;

    Status = XGpio_Initialize(gpio, dev);
    if (Status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    XGpio_SetDataDirection(gpio, pwr_chn, pwr_dir);
    XGpio_SetDataDirection(gpio, clk_chn, clk_dir);

	return XST_SUCCESS;
}

int setup_i2c(XIicPs *i2c_dev, XIicPs_Config *i2c_conf, u16 i2c_dev_id, u32 i2c_clk_freq){
	int Status;
	i2c_conf = XIicPs_LookupConfig(i2c_dev_id);
    if (i2c_conf == NULL) {
        return XST_FAILURE;
    }

    Status = XIicPs_CfgInitialize(i2c_dev, i2c_conf, i2c_conf->BaseAddress);
    if (Status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    Status = XIicPs_SelfTest(i2c_dev);
    if (Status != XST_SUCCESS) {
      return XST_FAILURE;
    }
    xil_printf("I2C self test passed!\r\n");

    Status = XIicPs_SetSClk(i2c_dev, i2c_clk_freq);
    if (Status != XST_SUCCESS) {
      return XST_FAILURE;
    }

    return XST_SUCCESS;
}

int setup_interrupt(XScuGic *gic_dev, XScuGic_Config *gic_conf, u16 gic_dev_id){
	int Status;
	gic_conf = XScuGic_LookupConfig(gic_dev_id);
	if (gic_conf == NULL) {
		xil_printf("XScuGic_LookupConfig(%d) failed\r\n", gic_dev_id);
		return XST_FAILURE;
	}

	Status = XScuGic_CfgInitialize(gic_dev, gic_conf, gic_conf->CpuBaseAddress);
	if (Status != XST_SUCCESS) {
		xil_printf("XScuGic_CfgInitialize failed\r\n");
		return XST_FAILURE;
	}
	return XST_SUCCESS;
}

int setup_cdma(XAxiCdma *cdma_dev, XAxiCdma_Config *){
	int Status;

	return XST_SUCCESS;
}

void power_up_cam(XGpio *gpio, u16 dev, unsigned pwr_down_chan, unsigned clk_enable_chan){
    XGpio_DiscreteWrite(gpio, pwr_down_chan, 1);
    usleep(5000);
    XGpio_DiscreteWrite(gpio, pwr_down_chan, 0);
    usleep(5000);
    XGpio_DiscreteWrite(gpio, clk_enable_chan, 1);
    usleep(5000);
}




int main (void) {

	u8 select;
	int i, CDMA_Status;
    int numofbytes;
    u8 * source, * destination;
    u8 * cdma_memory_source, * cdma_memory_destination;
    u32 test_done = 0;


    u32 Status;

    // CDMA related definitions
	XAxiCdma xcdma;
    XAxiCdma_Config * CdmaCfgPtr;

	// PS Interrupt related definitions
	XScuGic_Config *GicConfig;


	// Initialize GIC
	Status = setup_interrupt();

	// Disable DCache
	Xil_DCacheDisable();

    print("-- Simple DMA Design Example --\r\n");


	// Setup DMA Controller
    CdmaCfgPtr = XAxiCdma_LookupConfig(XPAR_AXI_CDMA_0_DEVICE_ID);
   	if (!CdmaCfgPtr) {
   		return XST_FAILURE;
   	}

   	Status = XAxiCdma_CfgInitialize(&xcdma , CdmaCfgPtr, CdmaCfgPtr->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
		xil_printf("Status=%x\r\n",Status);
	}

	print("Central DMA Initialized\r\n");

	print("Setting up interrupt system\r\n");
	Status = SetupIntrSystem(&Gic, &xcdma);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	Xil_ExceptionEnable();


	numofbytes = 10;
	xil_printf("Number of words to transfer %d\r\n", numofbytes);

    if(numofbytes > BUFFER_LENGTH)
    	numofbytes = BUFFER_LENGTH;


    select = '1';
    test_done = 0;
    while(test_done==0)
    {
		switch(select)
		{
/*
			case '1' :
				source = PROCESSOR_BRAM_MEMORY; // for processor to access the memory
				cdma_memory_source = CDMA_BRAM_MEMORY; // for CDMA to access the memory
				destination = PROCESSOR_BRAM_MEMORY+LENGTH;
				cdma_memory_destination = CDMA_BRAM_MEMORY+LENGTH; // for CDMA to access the memory
				print("BRAM to BRAM transfer\r\n");
				break;
*/
			case '1' :
	//			case '2' :
				source = (u8 *)PROCESSOR_BRAM_MEMORY;
				cdma_memory_source = (u8 *)CDMA_BRAM_MEMORY;
				destination = (u8 *)DDR_MEMORY;
				cdma_memory_destination = (u8 *)DDR_MEMORY;
				print("BRAM to DDR transfer\r\n");
				break;
			case '2' :
	//			case '3' :
				source = (u8 *)DDR_MEMORY;
				cdma_memory_source = (u8 *)DDR_MEMORY;
				destination = (u8 *)PROCESSOR_BRAM_MEMORY;
				cdma_memory_destination = (u8 *)CDMA_BRAM_MEMORY; // for CDMA to access the memory
				print("DDR to BRAM transfer\r\n");
				break;

		}
		if(test_done)
			break;

		// Initialize src memory
		for (i=0; i<numofbytes; i++)
			*(source+i) = numofbytes-i;

		/*
		 * NO DMA FROM HERE --------------------------------------------------------------
		 */

		print("Starting transfer without DMA\r\n");

		// start moving data through the processor - no CDMA, no interrupt
		// gives base consumed cycles
		for (i=0; i<numofbytes; i++)
			*(destination+i) = *(source+i);

		for (i = 0; i < numofbytes; i++) {
			xil_printf("Data match at = %d, source data = %x, destination data = %x\n\r",i,source[i],destination[i]);

				if ( destination[i] != source[i]) {
					break;
				}
			}


		/*
		 * DMA NOT USING INTERRUPTS FROM HERE --------------------------------------------------------------
		 */

		// clear destination memory
		for (i=0; i<numofbytes; i++)
			*(destination+i) = 0;

    	// DMA in polling mode
		XAxiCdma_IntrDisable(&xcdma, XAXICDMA_XR_IRQ_ALL_MASK);
		print("Starting transfer through DMA in poll mode\r\n");
		// reset timer
		Status = XAxiCdma_SimpleTransfer(&xcdma, (u32) cdma_memory_source, (u32) cdma_memory_destination,
				                         numofbytes, NULL, NULL);

		if (Status != XST_SUCCESS) {
			CDMA_Status = XAxiCdma_GetError(&xcdma);
			if (CDMA_Status != 0x0) {
				XAxiCdma_Reset(&xcdma);
				xil_printf("POLLING MODE ERROR pre ------------\n\r");
				print_cdma_error(CDMA_Status);

			}
			return XST_FAILURE;
		}

	   	while (XAxiCdma_IsBusy(&xcdma)); // Wait

		CDMA_Status = XAxiCdma_GetError(&xcdma);
		if (CDMA_Status != 0x0) {
			XAxiCdma_Reset(&xcdma);
			xil_printf("POLLING MODE ERROR post ------------\n\r");
			print_cdma_error(CDMA_Status);
		}
		else {
			print("Transfer complete\r\n");
			Error = 0; // reset for interrupt mode transfer
		}

		for (i = 0; i < numofbytes; i++) {
				if ( destination[i] != source[i]) {
					xil_printf("Data match failed at = %d, source data = %x, destination data = %x\n\r",i,source[i],destination[i]);
					break;
				}
			}
		print("Transfered data verified\r\n");


		/*
		 * DMA USING INTERRUPTS FROM HERE --------------------------------------------------------------
		 */


		// setting up for interrupt driven DMA
		// clear destination memory
		for (i=0; i<numofbytes; i++)
			*(destination+i) = 0;

		Error = 0;
		Done = 0;

		XAxiCdma_IntrEnable(&xcdma, XAXICDMA_XR_IRQ_ALL_MASK);
	    Status = XAxiCdma_SimpleTransfer(&xcdma, (u32)cdma_memory_source, (u32) cdma_memory_destination, numofbytes, Example_CallBack, (void *) &xcdma);


		while ((Done==0) & (Error==0)); // Wait until "Example_Callback" sets Done or Error to 1

		if (Error != 0x0) {
			xil_printf("INTERRUPT MODE Error '''''''''''''''''''''''''''''\r\n");
			CDMA_Status = XAxiCdma_GetError(&xcdma);
			print_cdma_error(CDMA_Status);
			XAxiCdma_Reset(&xcdma);
		}
		else {
			print("Transfer complete\r\n");
			Error = 0; // reset for interrupt mode transfer
		}

		for (i = 0; i < numofbytes; i++) {
				xil_printf("Data match failed at = %d, source data = %x, destination data = %x\n\r",i,source[i],destination[i]);
				if ( destination[i] != source[i]) {

					break;
				}
			}
		Error = 0;
		Done = 0;
		test_done = 1;
    }
    print("-- Exiting main() --\r\n");
    return 0;
}

